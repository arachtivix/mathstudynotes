"""Script to render imported mesh from 6 different camera angles.

This script takes a mesh JSON string (as generated by utilities.export_mesh_data),
applies an interesting material, and renders it from positive and negative directions
of each axis (6 views total).
"""

import bpy
import math
from mathutils import Vector
import json
from utilities import import_mesh_data

def create_metallic_material(name, color=(0.8, 0.8, 0.8, 1.0), roughness=0.2, metallic=0.8):
    """Create a metallic material with the specified properties."""
    material = bpy.data.materials.new(name=name)
    material.use_nodes = True
    nodes = material.node_tree.nodes
    links = material.node_tree.links
    
    # Use existing Principled BSDF node
    principled = nodes["Principled BSDF"]
    output = nodes["Material Output"]
    
    # Set material properties
    principled.inputs['Base Color'].default_value = color
    principled.inputs['Metallic'].default_value = metallic
    principled.inputs['Roughness'].default_value = roughness
    
    # Link nodes (ensure proper connection to output)
    links.new(principled.outputs['BSDF'], output.inputs['Surface'])
    
    return material

def setup_lighting():
    """Set up three-point lighting for good object visibility."""
    # Key light
    key_data = bpy.data.lights.new(name="Key_Light", type='AREA')
    key_data.energy = 400.0
    key_light = bpy.data.objects.new(name="Key_Light", object_data=key_data)
    bpy.context.scene.collection.objects.link(key_light)
    key_light.location = (5, -5, 5)
    key_light.rotation_euler = (math.radians(45), 0, math.radians(45))
    
    # Fill light
    fill_data = bpy.data.lights.new(name="Fill_Light", type='AREA')
    fill_data.energy = 200.0
    fill_light = bpy.data.objects.new(name="Fill_Light", object_data=fill_data)
    bpy.context.scene.collection.objects.link(fill_light)
    fill_light.location = (-5, -3, 3)
    fill_light.rotation_euler = (math.radians(30), 0, math.radians(-45))
    
    # Back light
    back_data = bpy.data.lights.new(name="Back_Light", type='AREA')
    back_data.energy = 300.0
    back_light = bpy.data.objects.new(name="Back_Light", object_data=back_data)
    bpy.context.scene.collection.objects.link(back_light)
    back_light.location = (0, 5, 4)
    back_light.rotation_euler = (math.radians(-30), 0, math.radians(180))

def setup_camera(location, target_location=(0, 0, 0)):
    """Set up camera at specified location, pointing at target."""
    bpy.ops.object.camera_add(location=location)
    camera = bpy.context.active_object
    
    # Point camera at target
    direction = Vector(target_location) - camera.location
    rot_quat = direction.to_track_quat('-Z', 'Y')
    camera.rotation_euler = rot_quat.to_euler()
    
    return camera

def setup_scene():
    """Set up the scene with default render settings."""
    scene = bpy.context.scene
    
    # Set render engine and output settings
    scene.render.engine = 'CYCLES'
    scene.cycles.samples = 128
    
    # Set render resolution
    scene.render.resolution_x = 1024
    scene.render.resolution_y = 1024
    scene.render.resolution_percentage = 100
    
    # Enable transparency in render
    scene.render.film_transparent = True
    
    # Set background color to light gray
    world = bpy.data.worlds['World']
    if 'Background' not in world.node_tree.nodes:
        world.use_nodes = True
        bg = world.node_tree.nodes['Background']
        bg.inputs[0].default_value = (0.9, 0.9, 0.9, 1)

def render_views(obj, base_path):
    """Render object from 6 different views (+/- each axis)."""
    # Calculate camera distance based on object size
    max_dim = max(obj.dimensions)
    cam_distance = max_dim * 2.5
    
    # Camera positions for each view
    positions = [
        (cam_distance, 0, 0),  # +X
        (-cam_distance, 0, 0), # -X
        (0, cam_distance, 0),  # +Y
        (0, -cam_distance, 0), # -Y
        (0, 0, cam_distance),  # +Z
        (0, 0, -cam_distance)  # -Z
    ]
    
    view_names = ['pos_x', 'neg_x', 'pos_y', 'neg_y', 'pos_z', 'neg_z']
    
    # Render each view
    for pos, name in zip(positions, view_names):
        camera = setup_camera(pos)
        bpy.context.scene.camera = camera
        
        # Set output path
        bpy.context.scene.render.filepath = f"{base_path}_{name}.png"
        
        # Render
        bpy.ops.render.render(write_still=True)
        
        # Clean up camera
        bpy.data.objects.remove(camera, do_unlink=True)

def main(json_str, output_path="//render"):
    """Main function to import mesh and render views.
    
    Args:
        json_str: JSON string containing mesh data
        output_path: Base path for rendered images
    """
    # Clear existing mesh objects
    bpy.ops.object.select_all(action='DESELECT')
    bpy.ops.object.select_by_type(type='MESH')
    bpy.ops.object.delete()
    
    # Import mesh
    obj = import_mesh_data(json_str, "RenderObject")
    
    # Apply material
    material = create_metallic_material("ObjectMaterial", 
                                      color=(0.75, 0.6, 0.3, 1.0),
                                      roughness=0.2,
                                      metallic=0.9)
    if obj.data.materials:
        obj.data.materials[0] = material
    else:
        obj.data.materials.append(material)
    
    # Center object
    obj.location = (0, 0, 0)
    
    # Setup scene
    setup_scene()
    setup_lighting()
    
    # Render views
    render_views(obj, output_path)

if __name__ == "__main__":
    # Example usage (replace with actual JSON string)
    example_json = '''{"vertices": [[1,1,1],[-1,1,1],[-1,-1,1],[1,-1,1],
                                  [1,1,-1],[-1,1,-1],[-1,-1,-1],[1,-1,-1]],
                      "faces": [[0,1,2],[0,2,3],[0,4,7],[0,7,3],[3,7,6],
                               [3,6,2],[2,6,5],[2,5,1],[1,5,4],[1,4,0],
                               [4,5,6],[4,6,7]]}'''
    main(example_json)