\documentclass{article}
\usepackage{amsmath}

\title{The Art of Computer Programming -- Chapter 2.2.1 Problem 4}
\author{Daniel Werner}

\begin{document}

\maketitle

\section*{
    Problem Statement
}

Find a simple formula for the number of permutations on n elements that can be obtained with a stack like that in exercise 2.

\section*{
    Analysis
}

Some information gathered from the previous problems:
\begin{enumerate}
  \item For a given input size $n$, there will be $2n$ characters in its 'S' and 'X' representation.
  \item Valid 'S' and 'X' representations can be identified by applying a simple counting rule that ensures there are the same number of S and X characters and that the running total of X never exceeds the running total of S.
\end{enumerate}

With this information, I will attempt to construct a recurrence that accurately models the 'S' and 'X' notation rules, then attempt to reduce that recurrence to a closed form.

\subsection*{Approach 1: special cases (dead end so far)}

One way I have considered to start on this problem is to consider special or simplifying cases first.  If the stack is limited in size, it could make the analysis easier by seeing what happens when its usage is allowed to increase.  I'll treat this like another parameter to our function, so whereas I am ultimately looking for $a_n$ as a function of $n$, for now I will look at $a_{m,n}$ where $m$ is the maximum stack size and $n$ is still the input size.  It is easy to see that:

\begin{equation*}
  a_{0,n} = 1
\end{equation*}

for any value of $n$.  This is because $a_{0,n}$ just means we never use the stack -- the output can only accept the same order as the input, which is exactly one permutation.  The question of $a_{1,n}$ is more interesting.  This function is like saying you can take any single input and move it as far back as you like:

\begin{equation*}
  \{ p_1,p_2,...p_{n-1},p_{n} \}
  \rightarrow
  \{ p_2,p_3,...p_{n-1},p_{n},p_{1} \}
\end{equation*}

This is not a complete description though, as when the new position for $a_1$ is less than $n$, there is the opportunity to move another element back as well:

\begin{equation*}
  \{ p_1,p_2,...p_{n-1},p_{n} \}
  \rightarrow
  \{ p_2,p_3,...,p_k,p_1,p_{k+1}...p_{n-1},p_{n} \}
\end{equation*}

The remaining tail sequence $\{p_{k+1},...,p_n\}$ can be treated the same recrusively as the larger sequence, this time with $n - k$ elements. So for $a_{1,n}$, you can look at it as having $n$ choices of where to put the first character in the sequence (including keeping it where it is) and walking a tree of possibilities from each choice.  This self similarity allows me to express all these choices as a sum:

\begin{equation}
  a_{1,n} = 1 + \sum_{k=1}^{n-1} a_{1,k}
\end{equation}

This sum nicely adheres to the clearly demonstrable base case of $a_{1,0} = 1$, as mentioned before since the number of permutations available for a zero length input is 1, regardless of maximum stack size.  While this is not even a decent form for the solution to $a_{1,n}$, it would be nice to check some values to make sure this is right.  Some modification on the script I wrote for problem 2 should help to find small values of this problem with the stack size restricted to 1.  Both the simulation and the sum seem to agree that:

\begin{equation*}
  a_{1,n} = 2^{n -1}
\end{equation*}

\par

This is interesting, but I do not see the path forward yet.

\subsection*{Approach 2: reasoning with the 'SX' form}

If I knew the insertion patterns for all valid permutations on $n - 1$, the only valid ones involving the nth element would be after $n - 1$ occurrences of S.  If the last S occurs in position $p_k$, then there would be $n - p + 1$ places for the additional S somewhere in the sequence and then another count of spaces available for the additional X that would have to occur (at any time) after that. Here are the valid patterns for 2-element inputs:

\begin{align*}
  SXSX \rightarrow \{1~2\} \\
  SSXX \rightarrow \{2~1\}
\end{align*}

Adding another input element, tracing back to which pattern can be said to be the parent, using lowercase for the parent and upper for the child:

\begin{align*}
  SXSX \rightarrow \{ SXSXsx, SXSsxX \} &= \{\{1~2~3\},\{1~3~2\}\} \\
  SSXX \rightarrow \{ SSsxXX,SSXsxX,SSXXsx \} &= \{\{3~2~1\},\{2~3~1\},\{2~1~3\}\}
\end{align*}

This seems quite nice, but not perfectly useful yet.  Since there are no remaining S's, this means only the location of the inserted S is meaningful, as the Xs do the same thing whether they are from the new pattern or the old.  The reason this does not seem immediately useful though is that there is still the question of how to count trailing Xs on the patterns from the permutations on $n - 1$ elements.

\par

I can see that this turns on the number of trailing Xs and it should be helpful to think of the patterns provided by adding an 'sx' to a pattern with k trailing X's will result in a single new pattern with k + 1 trailing X's, a single with k traling X's, and so forth down to a pattern with a single trailing x from the insertion itself.  SXSX yields two new patterns and SSXX yeilds three because the latter has one more trailing.

\par

For a given pattern ending in k X's, the number of resulting children is:

\begin{align}
  direct~child~count=trailing~X~count + 1
\end{align}

Each child will have a certain trailing X count and there will be one of each.  It turns out to be a little helpful to just ignore the characters preceding the last Xs and tally the counts of those with the same numer of last Xs.  Take the transition from $a_2$ to $a_3$:

\begin{align*}
  a_2 = \{SXSX,SSXX\} \rightarrow a_3 =
  \left\{
    \begin{aligned}
      & SXSXSX, SXSXSSX, SSSXXX, \\
      & SSXSXX, SSXXSX
    \end{aligned}
  \right\}
\end{align*}

The same in abbreviated, grouped form:

\begin{align*}
  a_2 = \{1 * ...SX,1 * ...SXX\} \rightarrow a_3 =
  \left\{
    \begin{aligned}
      & 2 * ...SX, 2 * ...SXX, \\
      & 1 * ...SXXX
    \end{aligned}
  \right\}
\end{align*}

Because any ...SXXX could be turned into a ...SXXXX or a ...stay a SXXX, or get demoted to a SXX or a SX,

\begin{align*}
  \{1 * ...SXXX\} \rightarrow
  \left\{
    \begin{aligned}
      & 1 * ...SX, 1 * ...SXX, 1 * ...SXXX, \\
      & 1 * ...SXXXX
    \end{aligned}
  \right\}
\end{align*}

But this is not a scenario that happens by itself in the process.  Instead, we get the combined, where:



\begin{align*}
  a_3 = 
  \left\{
    \begin{aligned}
      & 2 * ...SX, 2 * ...SXX, \\
      & 1 * ...SXXX
    \end{aligned}
  \right\} \rightarrow a_4 =
  \left\{
    \begin{aligned}
      & 5 * ...SX, 5 * ...SXX, 3 * ...SXXX, \\
      & 1 * ...SXXXX
    \end{aligned}
  \right\}
\end{align*}

\par

A table will help to start the efforts to make this process possibly easier to track:

\begin{table}[h!]
\centering
 \begin{tabular}{|c | c | c | c | c | c | c|} 
 \hline
 $n$ & $a_n$ & ...SX & ...SXX & ...SXXX & ...SXXXX & ...SXXXXX \\ [0.5ex] 
 \hline
 1 & 1 & 1 &  &  &  & \\ 
 2 & 2 & 1 & 1 &  &  & \\
 3 & 5 & 2 & 2 & 1 &  & \\
 4 & 14 & 5 & 5 & 3 & 1 & \\
 5 & 42 & 14 & 14 & 9 & 4 & 1 \\
 \hline
 \end{tabular}
\end{table}

\end{document}